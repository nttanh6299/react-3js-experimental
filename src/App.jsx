import { useRef, useEffect, Suspense, useLayoutEffect } from 'react';
import {
  TextureLoader,
  RepeatWrapping,
  Vector3,
  Quaternion,
  SRGBColorSpace,
  LinearSRGBColorSpace,
} from 'three';
import { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';
import {
  OrbitControls,
  useGLTF,
  Stage,
  useTexture,
  MeshReflectorMaterial,
  Reflector,
  useAnimations,
} from '@react-three/drei';
import { create } from 'zustand';
import { useControls } from 'leva';

export const W = 'w';
export const A = 'a';
export const S = 's';
export const D = 'd';
const DIRECTIONS = [W, A, S, D];

const useControlStore = create((set) => ({
  orbitControls: null,
  setOrbitControls: (orbitControls) => set(() => ({ orbitControls })),
}));

const keysPressed = {};
const walkDirection = new Vector3();
const rotateAngle = new Vector3(0, 1, 0);
const rotateQuarternion = new Quaternion();
const cameraTarget = new Vector3();
let holdingShift = false;
let enableTPose = false;
let currentAction = 'Idle';
let additiveWeight = 0;
const weightSpeed = 0.02;

function getDirectionOffset(keysPressed) {
  let directionOffset = 0; // w

  if (keysPressed[W]) {
    if (keysPressed[A]) {
      directionOffset = Math.PI / 4; // w+a
    } else if (keysPressed[D]) {
      directionOffset = -Math.PI / 4; // w+d
    }
  } else if (keysPressed[S]) {
    if (keysPressed[A]) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (keysPressed[D]) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (keysPressed[A]) {
    directionOffset = Math.PI / 2; // a
  } else if (keysPressed[D]) {
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

const handleKeyDown = (event) => {
  if (event.key === 'Shift') {
    holdingShift = true;
  }
  if (event.key === 't' || event.key === 'T') {
    enableTPose = !enableTPose;
  }
  keysPressed[event.key.toLowerCase()] = true;
};

const handleKeyUp = (event) => {
  if (event.key === 'Shift') {
    holdingShift = false;
  }
  keysPressed[event.key.toLowerCase()] = false;
};
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

function Model(props) {
  const { scene } = useGLTF('/models/weapon_knife_butterfly.glb');
  const texture = useTexture('/textures/45215c5a5683ae98ffc37c9b772ac94f_component1_texture1.png');
console.log(scene)
  useLayoutEffect(() => {
    scene.traverse((obj) => {
      if (obj.isMesh) {
        obj.castShadow = obj.receiveShadow = false;
        obj.material.envMapIntensity = 0.8;

        if (obj.name === 'model') {
          obj.visible = false;
        }

        if (obj.name === 'legacy') {
          texture.colorSpace = SRGBColorSpace;
          texture.flipY = false;
          texture.wrapS = RepeatWrapping;
          texture.wrapT = RepeatWrapping;
          obj.material.map = texture;
          obj.material.roughness = 0.5;
        }
      }
    });
  }, [scene]);

  return (
    // <Center ref={ref} {...props} dispose={null}>
    //   <primitive object={scene} />
    // </Center>
    <Stage intensity={0.8} environment="warehouse" adjustCamera={false}>
      <primitive object={scene} />
    </Stage>
  );
}

useGLTF.preload('/weapon_rif_m4a1_silencer.glb');

const Floor = () => {
  const [colorTexture, normalTexture, displacementTexture, aoMapTexture] = useLoader(
    TextureLoader,
    [
      '/textures/sand/color.jpg',
      '/textures/sand/normal.jpg',
      '/textures/sand/height.jpg',
      '/textures/sand/ao.jpg',
    ],
  );

  // Repeat the textures
  const repeatX = 10;
  const repeatY = 10;
  colorTexture.repeat.set(repeatX, repeatY);
  normalTexture.repeat.set(repeatX, repeatY);
  displacementTexture.repeat.set(repeatX, repeatY);
  aoMapTexture.repeat.set(repeatX, repeatY);

  // Enable texture wrapping
  colorTexture.wrapS = colorTexture.wrapT = RepeatWrapping;
  normalTexture.wrapS = normalTexture.wrapT = RepeatWrapping;
  displacementTexture.wrapS = displacementTexture.wrapT = RepeatWrapping;
  aoMapTexture.wrapS = aoMapTexture.wrapT = RepeatWrapping;

  return (
    <mesh receiveShadow rotation-x={-Math.PI / 2}>
      <planeGeometry args={[80, 80, 512, 512]} />
      <meshStandardMaterial
        map={colorTexture}
        normalMap={normalTexture}
        displacementMap={displacementTexture}
        aoMap={aoMapTexture}
        displacementScale={0.1}
      />
    </mesh>
  );
};

const Light = () => {
  return (
    <>
      {/* <Environment preset="city" blur={1} /> */}
      {/* <directionalLight
        position={[-60, 100, -10]}
        color={'white'}
        intensity={3}
        castShadow
        shadow-mapSize-width={4096}
        shadow-mapSize-height={4096}
        shadow-camera-near={0.1}
        shadow-camera-far={200}
      /> */}
      {/* <ambientLight intensity={0.7} /> */}
      {/* <spotLight intensity={0.5} angle={0.1} penumbra={1} position={[10, 15, 10]} castShadow /> */}
    </>
  );
};

// const Scene = () => {
//   const { setOrbitControls } = useControlStore();

//   return (
//     <>
//       <color attach="background" args={['#a8def0']} />
//       <Light />
//       <Floor />
//       <Suspense fallback={null}>
//         <Model path={'/models/Soldier.glb'} pose={'Idle'} />
//       </Suspense>
//       <OrbitControls
//         ref={setOrbitControls}
//         enableDamping
//         minDistance={4}
//         maxDistance={15}
//         maxPolarAngle={Math.PI / 2 - 0.1}
//       />
//     </>
//   );
// };

function CameraControls() {
  // Sử dụng Leva để tạo giao diện điều chỉnh position
  const { cameraPosition, cameraRotation } = useControls({
    cameraPosition: { value: [1.5, 0.3, 0], min: -10, max: 10, step: 0.1 },
  });

  const { camera } = useThree();

  useEffect(() => {
    // Chỉnh sửa vị trí camera
    camera.position.set(...cameraPosition);
  }, [camera, cameraPosition, cameraRotation]);

  return null;
}

const Scene = () => {
  const { setOrbitControls } = useControlStore();

  return (
    <>
      <color attach="background" args={['#ebf2fc']} />
      {/* <Floor /> */}
      {/* <Leva collapsed={false} /> */}
      <Light />
      <Suspense fallback={null}>
        {/* <Environment preset="city" /> */}
        {/* <Model path={'https://3d.cs.money/models/weapon_rif_m4a1_silencer.glb'} /> */}
        <Model position={[0, 0, 0]} />
        <directionalLight position={[7, 0, 3]} color="#ebf2fc" intensity={0.8} />
      </Suspense>
      <OrbitControls
        ref={setOrbitControls}
        enableDamping={false}
        // enableDamping
        // minDistance={0}
        // maxDistance={10}
        // maxPolarAngle={Math.PI / 2 - 0.1}
      />
      <CameraControls />
    </>
  );
};

// camera={{ fov: 70, position: [0, 4, 3] }}

function App() {
  return (
    <Canvas flat shadows dpr={[1, 1.5]} camera={{ fov: 40 }}>
      <Scene />
    </Canvas>
  );
}

export default App;
